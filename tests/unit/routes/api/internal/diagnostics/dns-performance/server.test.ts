import { describe, it, expect, vi, beforeEach } from 'vitest';
import { POST } from '../../../../../../../src/routes/api/internal/diagnostics/dns-performance/+server';

// Mock DNS module to avoid real network calls
const mockResolverInstance = {
  setServers: vi.fn(),
  resolve4: vi.fn().mockResolvedValue(['93.184.216.34']),
  resolve6: vi.fn().mockResolvedValue(['2606:2800:220:1:248:1893:25c8:1946']),
  resolveMx: vi.fn().mockResolvedValue([{ priority: 10, exchange: 'mail.example.com' }]),
  resolveTxt: vi.fn().mockResolvedValue([['v=spf1 include:_spf.example.com ~all']]),
  resolveNs: vi.fn().mockResolvedValue(['ns1.example.com', 'ns2.example.com']),
  resolveCname: vi.fn().mockResolvedValue(['alias.example.com']),
  resolveSoa: vi.fn().mockResolvedValue({
    nsname: 'ns1.example.com',
    hostmaster: 'admin.example.com',
    serial: 2023010101,
    refresh: 3600,
    retry: 600,
    expire: 604800,
    minttl: 86400
  })
};

vi.mock('node:dns', () => ({
  default: {
    promises: {
      Resolver: vi.fn(() => mockResolverInstance)
    }
  },
  promises: {
    Resolver: vi.fn(() => mockResolverInstance)
  }
}));

// Mock the Request constructor for testing
const createMockRequest = (body: any) => ({
  json: vi.fn().mockResolvedValue(body)
} as unknown as Request);

describe('DNS Performance API Endpoint', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('POST Handler - Basic Functionality', () => {
    it('should accept valid domain and basic resolvers', async () => {
      const request = createMockRequest({
        domain: 'example.com',
        recordType: 'A',
        resolvers: ['8.8.8.8', '1.1.1.1'],
        timeoutMs: 5000
      });

      const response = await POST({ request } as any);
      expect(response.status).toBe(200);

      const data = await response.json();
      expect(data).toHaveProperty('domain', 'example.com');
      expect(data).toHaveProperty('recordType', 'A');
      expect(data).toHaveProperty('results');
      expect(Array.isArray(data.results)).toBe(true);
    });

    it('should handle AAAA record type', async () => {
      const request = createMockRequest({
        domain: 'ipv6.google.com',
        recordType: 'AAAA',
        resolvers: ['8.8.8.8'],
        timeoutMs: 5000
      });

      const response = await POST({ request } as any);
      expect(response.status).toBe(200);

      const data = await response.json();
      expect(data.recordType).toBe('AAAA');
    });

    it('should handle MX record type', async () => {
      const request = createMockRequest({
        domain: 'gmail.com',
        recordType: 'MX',
        resolvers: ['8.8.8.8'],
        timeoutMs: 5000
      });

      const response = await POST({ request } as any);
      expect(response.status).toBe(200);

      const data = await response.json();
      expect(data.recordType).toBe('MX');
    });

    it('should handle custom timeout values', async () => {
      const request = createMockRequest({
        domain: 'example.com',
        recordType: 'A',
        resolvers: ['8.8.8.8'],
        timeoutMs: 3000
      });

      const response = await POST({ request } as any);
      expect(response.status).toBe(200);
    });

    it('should handle multiple custom resolvers', async () => {
      const request = createMockRequest({
        domain: 'example.com',
        recordType: 'A',
        resolvers: ['8.8.8.8', '1.1.1.1', '9.9.9.9'],
        timeoutMs: 5000
      });

      const response = await POST({ request } as any);
      expect(response.status).toBe(200);

      const data = await response.json();
      expect(data.results.length).toBeGreaterThanOrEqual(3);
    });
  });

  describe('POST Handler - Validation', () => {
    it('should reject missing domain', async () => {
      const request = createMockRequest({
        recordType: 'A',
        customResolvers: ['8.8.8.8'],
        timeoutMs: 5000
      });

      try {
        await POST({ request } as any);
        expect(false).toBe(true); // Should not reach here
      } catch (error: any) {
        expect(error.status).toBe(400);
        expect(error.body.message).toBe('Domain is required');
      }
    });

    it('should reject invalid domain format', async () => {
      const request = createMockRequest({
        domain: 'invalid..domain',
        recordType: 'A',
        customResolvers: ['8.8.8.8'],
        timeoutMs: 5000
      });

      try {
        await POST({ request } as any);
        expect(false).toBe(true); // Should not reach here
      } catch (error: any) {
        expect(error.status).toBe(400);
        expect(error.body.message).toBe('Invalid domain name format');
      }
    });

    it('should reject invalid record type', async () => {
      const request = createMockRequest({
        domain: 'example.com',
        recordType: 'INVALID',
        customResolvers: ['8.8.8.8'],
        timeoutMs: 5000
      });

      try {
        await POST({ request } as any);
        expect(false).toBe(true); // Should not reach here
      } catch (error: any) {
        expect(error.status).toBe(400);
        expect(error.body.message).toContain('Invalid record type');
      }
    });

    it('should filter out invalid resolver IPs', async () => {
      const request = createMockRequest({
        domain: 'example.com',
        recordType: 'A',
        customResolvers: ['invalid-ip', '8.8.8.8'],
        timeoutMs: 5000
      });

      const response = await POST({ request } as any);
      expect(response.status).toBe(200);

      const data = await response.json();
      expect(data.results.some((r: any) => r.resolver === '8.8.8.8')).toBe(true);
      expect(data.results.some((r: any) => r.resolver === 'invalid-ip')).toBe(false);
    });

    it('should clamp low timeout values to minimum', async () => {
      const request = createMockRequest({
        domain: 'example.com',
        recordType: 'A',
        customResolvers: ['8.8.8.8'],
        timeoutMs: 100
      });

      const response = await POST({ request } as any);
      expect(response.status).toBe(200);
      // Server clamps timeout to minimum instead of rejecting
    });

    it('should clamp high timeout values to maximum', async () => {
      const request = createMockRequest({
        domain: 'example.com',
        recordType: 'A',
        customResolvers: ['8.8.8.8'],
        timeoutMs: 31000
      });

      const response = await POST({ request } as any);
      expect(response.status).toBe(200);
      // Server clamps timeout to maximum instead of rejecting
    });

    it('should limit custom resolvers to maximum allowed', async () => {
      const request = createMockRequest({
        domain: 'example.com',
        recordType: 'A',
        customResolvers: Array(15).fill('8.8.8.8'), // More than MAX_CUSTOM_RESOLVERS
        timeoutMs: 5000
      });

      const response = await POST({ request } as any);
      expect(response.status).toBe(200);
      // Server limits resolvers instead of rejecting
      const data = await response.json();
      expect(data.results.length).toBeLessThanOrEqual(20); // Default + custom limit
    });

    it('should reject domain that is too long', async () => {
      const request = createMockRequest({
        domain: 'a'.repeat(300) + '.com',
        recordType: 'A',
        customResolvers: ['8.8.8.8'],
        timeoutMs: 5000
      });

      try {
        await POST({ request } as any);
        expect(false).toBe(true); // Should not reach here
      } catch (error: any) {
        expect(error.status).toBe(400);
        expect(error.body.message).toBe('Invalid domain name format');
      }
    });
  });

  describe('POST Handler - Edge Cases', () => {
    it('should handle IPv6 resolvers', async () => {
      const request = createMockRequest({
        domain: 'example.com',
        recordType: 'A',
        resolvers: ['2001:4860:4860::8888'],
        timeoutMs: 5000
      });

      const response = await POST({ request } as any);
      expect(response.status).toBe(200);
    });

    it('should handle mixed IPv4 and IPv6 resolvers', async () => {
      const request = createMockRequest({
        domain: 'example.com',
        recordType: 'A',
        resolvers: ['8.8.8.8', '2001:4860:4860::8888'],
        timeoutMs: 5000
      });

      const response = await POST({ request } as any);
      expect(response.status).toBe(200);
    });

    it('should handle subdomain with multiple levels', async () => {
      const request = createMockRequest({
        domain: 'test.sub.example.com',
        recordType: 'A',
        resolvers: ['8.8.8.8'],
        timeoutMs: 5000
      });

      const response = await POST({ request } as any);
      expect(response.status).toBe(200);
    });

    it('should handle different record types correctly', async () => {
      const recordTypes = ['A', 'AAAA', 'MX', 'TXT', 'NS', 'CNAME'];

      for (const recordType of recordTypes) {
        const request = createMockRequest({
          domain: 'example.com',
          recordType,
          resolvers: ['8.8.8.8'],
          timeoutMs: 5000
        });

        const response = await POST({ request } as any);
        expect(response.status).toBe(200);

        const data = await response.json();
        expect(data.recordType).toBe(recordType);
      }
    });
  });

  describe('POST Handler - Error Handling', () => {
    it('should handle malformed JSON', async () => {
      const request = {
        json: vi.fn().mockRejectedValue(new Error('Invalid JSON'))
      };

      try {
        await POST({ request } as any);
        expect(false).toBe(true); // Should not reach here
      } catch (error: any) {
        expect(error.status).toBe(400);
        expect(error.body.message).toBe('Invalid JSON in request body');
      }
    });

    it('should handle missing request body', async () => {
      const request = createMockRequest(null);

      try {
        await POST({ request } as any);
        expect(false).toBe(true); // Should not reach here
      } catch (error: any) {
        expect(error.status).toBe(500);
        expect(error.body.message).toContain('Cannot destructure property');
      }
    });

    it('should include performance metrics in response', async () => {
      const request = createMockRequest({
        domain: 'example.com',
        recordType: 'A',
        resolvers: ['8.8.8.8'],
        timeoutMs: 5000
      });

      const response = await POST({ request } as any);
      expect(response.status).toBe(200);

      const data = await response.json();
      expect(data.results).toBeDefined();

      if (data.results.length > 0) {
        const result = data.results[0];
        expect(result).toHaveProperty('resolver');
        expect(result).toHaveProperty('success');

        if (result.success) {
          expect(result).toHaveProperty('responseTime');
          expect(typeof result.responseTime).toBe('number');
        }
      }
    });
  });
});